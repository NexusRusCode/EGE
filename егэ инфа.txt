1 - легчайшая, можно прорешивать для удовольствия

6 - легчайшая, или тупо вставлять программу, или то же самое, но добавлять цикл для перебора значений

19 - легкая, одна или две кучи:
— в одной куче очень сложно ошибиться, тупо шаблон - берешь макс значение / умножение в квадрате в задаче,  сложнейший вариант - когда петя не выигрывает за 1 раз и ваня выигрывает в любом случае, тупо подбор подходящего, НО увеличение в квадрат не делать;
— две кучи - высчитываем вторую кучу (всего - 1 куча), а затем - самое главное - проверяем умножение в квадарте * камней в куче для ОБОИХ куч, есть вариант с добавлением кол-ва камней в другой куче, тупо составляем неравенство для обоих куч(на всякий), считаем S. Всё!

10 - легчайшая, единственное важное обстоятельство - сказано ИЩИ ГЛАГОЛ, надо искать ГЛАГОЛ, не считать сноски и аннотации - НЕ СЧИТАТЬ ИХ. Остальное простейше, тупо расширенный поиск в ворде.

11 - в большинстве случаев легчайшая, единственное, что нужно запомнить - если говорят что хранится в БИТАХ, то считать как в БИТАХ, если упаковывать в БАЙТЫ - упаковывать в БАЙТЫ, а также запомнить про порядок расчета хранения диапазона значений (трехзначные, двухзначные и тд). Но существуют редкие, просто невъебенные задания, буквально в единичном экземпляре, на знание формулы: в алфавите состоящем из н символов н в степени м слов длиной м. Причем из 4 цифр (где цифры от 1 до 10) и л букв (где букв четыре) можно закодировать 4^L*10^4 символов.
20.06.2022 0.18 там где код подразделения - кодировка у цифр и смоволов РАЗДЕЛЬНАЯ

3 - есть легчайшие на магазины, а есть максимально убогие из банка фипи. Впринципе, первый вариант вообще наилегчайший, второй - тупо долгий, и нужно быть внимательным. Запомнить формулу ВПР на всякий, хотя в основном делается руками.

22 - тоже легчайшая. Единственное важное - есть жесткие варианты с полякова, там нужно смотреть, если там не равно, либо равно, то может идти бесконечное увеличение или уменьшение. В таком случае надо поставить логичные ограничения на это уменьшение/ограничение. В остальном такое же легкое как и 6.

9 - легчайшее, но нужно быть внимательным и запомнить формулы СРЗНАЧ, МАКС, СЧЕТЕСЛИ, МИН, ЕСЛИ, СУММ, СЧЕТЕСЛИМН(считает кол-во ячеек, удолетворяющих НАБОРУ условий). А так да, легкое. 

25 - элементарное. В новых заданиях с досрока на маски нужно быть внимательным, чтобы случайно не начать искать ненужного. Кроме того нужно помнить, что все расчеты нужно проводить от 1 до (int)(pow(i, 0.5)), и никак по другому, а иначе ошибки. 60 секунд на решение программе достаточно. Определение кол-ва делителей - просто делаем цикл от 1 до корня из числа, и проверяем делимость по циклу, если исходное число делится на данное число, т.е. является его делителем, то к числу делителей прибавляем 2. Если в задании не оговорено, то 1 и само число тоже считаем. Если к делителям есть особые требования, то при проверке текущего делителя k необходимо проверять также i/k, чтобы не увеличивать просто так время цикла. Случай, когда число является точным квадратом, прописывать отдельно, и при подсчете различных делителей отнимать единицу!!!

при нахождении кол-ва чисел, у которых не менее 3 пар сомножителей разность которых меньше х, не знаю почему - просто запомнить: считать от корня в МЕНЬШУЮ сторону. Почему - хз, но по другому ошибки выдает.

23 - одно из сложных, на понимание. От нас требуется создать симулятор дерева событий, в отдельной функции. В ней будет симулироваться расчет 3 возможных событий:
1. При увеличении числа n (неважно, каким способом) мы перескакиваем число m. Этот случай нам не подходит, поэтому функция в этом случае возвращает 0.
2. При увеличении числа n (неважно, каким способом) мы попадаем ровно в число m. Число таких событий мы и ищем. Поэтому функция должна возвращать 1. 
3. При увеличении числа n (неважно, каким способом) мы попадаем в значение меньшее, чем m. Тогда мы находимся на пути к концу в дереве, а не в конце, поэтому мы должны расчитать сумму для 2(или более) событий (т.к. от значения для данной ветки событий исходят еще 2 (или более) веток, каждая из которых это событие, такое же, которое мы рассчитываем прямо сейчас), т.е. рассчитать значение рекурсии для каждого события и суммировать их. Эту сумму функция и должна возвращать (return F(n+2, m)+F(n*2, m)).
Сам ответ - это произведение значений нашей функции для (n1, m1) и (m1, m2), где m1 - число в траектории, а n1 и  m2 - начальное и конечное числа соответственно, т.к. ответ это по сути кол-во путей из пункта А в пункт Б, проходящих через пункт С.
Поэтому 23 значительно сложнее, чем все задания, описанные выше.

24 - довольно сложная. На смекалку, так сказать. Бывает 2 случая данной задачи: первый случай - задание возможно решать и кодом, и в текстовом редакторе. Как правило это легкие варианты заданий. В этих заданиях требуется обычно найти максимальное кол-во последовательно идущих пар каких то символов. Мы можем заменить эти пары каким нибудь числом (например, 1) и затем подсчитать максимальное кол-во этих чисел постепенным увеличением возможной последовательности данных символов. Затем вырезаем ее и вставляем в конце файла. Затем заменяем каждую тройку чисел цифрой 3 и таким образом подсчитываем итоговое значение (для устранения возможности ошибиться). Если задание заключается не в этом, то все значительно сложнее и нужно писать код. Для кода необходимо запомнить методы библиотеки string, их список есть в репе в документе "строки". Многие из них содержат сложно запоминаемые параметры, а неправильная запись данных параметров зачастую не приводит к вылету или ошибке, в этом и заключается сложность. А так задание несложное, абсолютное большинство задач проверяет банальное знание основ работы со строками, а задания посложнее часто на смекалку.

2 - задание простое, его можно делать и руками, и кодом, лучше кодом, так как это быстрее, и в случаях когда задания сложные через код допустить ошибку сложнее. Для решения кодом нужно запомнить несколько фактов:
-сама обработка значений идет через подстановку 1/0 в цикле с такими же 3 вложенными циклами, где идет обработка каждой из 4 переменных из задачи
-следование(имликация)(<-)заменяется на <=
-логическое умножение заменяется на *
-сложение заменяется на +
-тождественность заменяется на ==
-исключающее или вряд ли будет:
1 1 0
0 0 0
1 0 1
0 1 1
-затем составляется таблица значений переменных, в которой посредством логики мы расставляем названия переменных
впринципе, ничего сложного
-19.06.2022 блять, завтра егэ, а я только сегодня понял почему у меня все время были ошибки в этом задании! если эти 4 (или 3) цикла выводят недостаточное кол-во строк, то в записанном условии ошибка! логическое или нужно заменять на or, а и - на and!!! А иначе ошибки!  

16 - простейшее, тупо берем код, вставляем его в иде, все!

7 - простейшее, необходимо знать буквально несколько формул, подвохов почти не бывает, изи крч
-18.06.2022 ага ага простейшее блять нихуя не простейшее вообще, существует несколько типов, 1 тип - на графику, существует формула V = M * i, где в это объем памяти на фотографию, м это размеры фото, i - бит на пиксель, и 2**i=максимальное кол-во цветов. 1 кб это 2**13 бит, 1мб это 2**23 бит, 2**33 это 1 гб. Есть также M=k*m*в**2, где в - dpi в квадрате, к - глубина кодирования, м - размеры в дюймах. Кратко - лучше считать в коде, т.к. задолбишься считать руками. Но аккуратнее со степенями, могут и запутать. Возможны вычислительные ошибки. там где глубина кодирования нецелая получается, всегда округляем в меньшую сторону. При счете в коде юзать лонг даббл. Там где задания на сжатие, иметь ввиду - файл по условию УЖЕ сжат. если добавляются доп данные - сразу же их отбрасываем. по графике все.
2 тип - на аудио
формула: V=i(глубина кодирования)*(число каналов)*(частота дискретизации)*(время записи)
все, на решу егэ нет никаких подвохов, единственно рекомендации: юзать лонг даббл, опасаться опечаток, лучше решать кодом, и проверять на бумаге
3 тип - передача
как оказалось, не такой простой. если дана х-битная кодировка, то это означает, что каждый символ несет в себе именно х бит. ретрансляция - передача всего файла по самому херовому потоку, полное время - получение первого пакета + ретрансляция. при округлении до целого не отбрасывать дробную часть, а именно округлять! килобит = 2**10 бит, мегабит - 2**20 бит, 1 килобайт = 8 килобит. на сравнение способов передачи - простое задание но громоздкое

17 - давным давно решал такие, простейшее, что пипец, тупо надо вспомнить код для обработки, а так простейшее

далее идут задания, которые можно спокойно делать в любых вариациях после проработки некоторой базы заданий 
или изучения некоторого кол-ва теории
-------------------------------------------------------------------------------------------
20 и 21 - не особо сложнее 19, схему расскажу позднее

4 - относительно сложное, необходимо знать прямое и обратное условия фано, а также контекст их применения в составлении слов из букв алфавита, больше ничего знать не надо
20.06.2022 5.12 простейшее задание. единственно сложное - понять где раздваивать, а так изи

5 - довольно простое задание, нужно лишь один раз понять суть прямого и обратного алгоритма и нарешать небольшую базу

8 - необходимо 1 раз узнать теорию для задания, а затем тупо нарешать базу заданий, несложное вообще
-5.37 изейшее, правило произведения и размещения, можно циклами вложенными в питоне, число перестановок - н факториал. фром итертулс импорт продукт. фор х ин продукт(крот, репит=6) с = ''.join(x). последний индекс - (-1). сет(пермутэйшнс) если перестановки (кол-во слов равно кол-ву букв), сет если есть повторения букв. нот ин с если не должно содержать группы букв. если много слов, то продуктом

12 - относительно сложное задание, существует несколько вариаций, простейшее на строки требует знания лишь примитивных методов строковых, остальные весьма сложны, специфичны и требуют проработки определенных знаний и теории, возможны подвохи

13 - блять ну изейшее, тупо на внимательность, необходимо 1 раз понять, как считать кол-во, а далее изейшее настолько же, насколько и 1, можно также в удовольствие нарешивать
-14.06.2022 блять ну реально простейшее, тупо расчет по графу: берем начальный пункт, там ставим 1, если в следующий пункт ведет только одна дорога, то в следующем пункте такое же число, если нет, то там сумма чисел в пунктах, из которых ведут дороги в данный пункт. ВСЕ!!! С обязательными или избегаемыми вершинами то же самое, просто обрезаем дороги, которые не подходят по условию, вот и все! Сложные варианты заданий с решу егэ и полякова вообще ни разу не сложные и хитростями не отличаются (самый длинный путь - замечаем, через какую точку необходимо пройти, или выписываем кратчайший путь для каждой точки, а далее - дело техники). Единственная сложность - если делать руками, то внимательно перепроверять, все ли движения изображены, а то уже были ошибки, связанные с этим. Главное - НЕ СПЕШИТЬ!!! 

14 - довольно сложное, и в самых простых, и в самых сложных вариациях необходимо знать алгоритм решения, немного теории и нарешивать, нарешивать, нарешивать...
19.06.2022 блять а че хуйня такая, вообще простецкая задача, тупо в питон закидываешь и все, даже делать ничего не надо.

15 - просто пиздец, очень сложное задание, нужно знать тонну теории, прорешать кучу заданий, возможны подвохи, короче трешняк полный
-19.06.2022 задача на побитовую конъюнкцию, на множества - изи, я их сам решаю в коде на раз два, тупо цикл для а где перебор х и у, и переменная состояния. все. но там где отрезки, и не простейший их вариант - становится страшно. лучше оставлять напоследок, если не решается кодом. импликация - если а, то б. сводить к читаемой имликации. и учить законы логики. или не учить а пытаться выводить за скобки. неважно с какой стороны импликация, и так и так читается. длина = конец - начало. если разрыв в отрезках - выбираем больший/меньший. если импликация вправо - объединение отрезков. А->В, А - подмножество множества В. к неотриц. относится 0, к положительным - нет.

18 - сложное, грубо говоря на знание экселя. Нужно уметь хорошо с ним работать, нужно проработать базу заданий и заучить некоторые формулы и алгоритм решения
----------------------------------------------------------------------------

26 и 27 - полуолимпиадные. Крайне сложные. Необходимо хорошо знать алгоритм обработки файлов, прорешать задания из досрока и типичные из фипи. Возможно, посмотреть видео конкретно по этим заданиям. А далее как бог даст, для этого задания нет конкретного алгоритма, кроме простейших с фипи.


--------------------------------------------------------------------------------------------------
резюмируя, на 13 июня, за неделю до егэ, в 21.30 - те задания, которые я уже решаю, дают мне по меньшей мере 70 баллов, если буквально парочку заданий пройти - 80. Но мне нужно 100. Для этого нужно прорешать вообще все задания, которые я еще не знаю. Также необходимо добавить в пункты по заданиям недостающую теорию. Необходимо прорешать граничные варианты, т.е. прорешать сложные варианты с полякова и решу егэ, для понимания сложности заданий со звездочкой. Впринципе, более менее я пока такие 17, 25 и 1 только решал. На решение 26 и 27 надеюсь в силу своего некоторого понимания и участия в олимпиадах, которые могут дать необходимые навыки в трудную минуту.

Перевод систем счисления в питоне - int(число, основание) - в десятичную из любой, bin, hex, oct - ну в общем понятно.